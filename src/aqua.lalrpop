grammar;

use std::str::FromStr;
use std::iter;

use ast::{RegisterAST, NumTypeAST, BitFieldAST, RegisterFieldAST, UnaryOperationAST, BinaryOperationAST, TermAST, ExpressionAST, FunctionAST};

Ident: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);

NumType: NumTypeAST = {
    "u8" => NumTypeAST::U8,
    "u16" => NumTypeAST::U16,
    "u32" => NumTypeAST::U32,
    "u64" => NumTypeAST::U64,
};

BitRange: (u8, u8) = {
    <hi:r"\d+"> ":" <lo:r"\d+"> => (u8::from_str(hi).unwrap(), u8::from_str(lo).unwrap()),
    r"\d+" => (u8::from_str(<>).unwrap(), u8::from_str(<>).unwrap())
};

BitField: BitFieldAST = {
    <name:Ident> "<" <bits:BitRange> ">" ";" => BitFieldAST {
        name,
        lo: bits.0,
        hi: bits.1
    }
};

RegisterField: RegisterFieldAST = {
    <field_type:NumType> "{" <bit_fields:BitField*> "}" => RegisterFieldAST {
        field_type,
        bit_fields
    }
};

pub Register: RegisterAST = {
    "register" <name:Ident> "{" <register_fields:RegisterField*> "}" => RegisterAST {
        name,
        register_fields
    }
};

pub UnaryOperation: UnaryOperationAST = {
    "~" => UnaryOperationAST::BitNot,
    "!" => UnaryOperationAST::BoolNot,
    "-" => UnaryOperationAST::Minus
};

pub BinaryOperation: BinaryOperationAST = {
    "+" => BinaryOperationAST::Add,
    "-" => BinaryOperationAST::Minus,
    "*" => BinaryOperationAST::Multiply,
    "/" => BinaryOperationAST::Divide,
    "%" => BinaryOperationAST::Modulo,
    "&" => BinaryOperationAST::BitAnd,
    "|" => BinaryOperationAST::BitOr,
    "^" => BinaryOperationAST::BitXor,
    "&&" => BinaryOperationAST::BoolAnd,
    "||" => BinaryOperationAST::BoolOr,
    "<" => BinaryOperationAST::Less,
    "<=" => BinaryOperationAST::LessEqual,
    ">" => BinaryOperationAST::Greater,
    ">=" => BinaryOperationAST::GreaterEqual,
    "==" => BinaryOperationAST::Equal
};

pub Term: TermAST = {
    Ident => TermAST::Ident(<>)
};

Factor: Box<ExpressionAST> = {
    Term => Box::new(ExpressionAST::Term(<>)),
    "(" <Expression> ")" => <>
};

pub Expression: Box<ExpressionAST> = {
    Expression BinaryOperation Factor => Box::new(ExpressionAST::BinaryOperation(<>)),
    UnaryOperation Factor => Box::new(ExpressionAST::UnaryOperation(<>)),
    Factor
};

ParamPair: (NumTypeAST, String) = {
    <a:NumType> <b:Ident> => (a, b)
};

ParamList: Vec<(NumTypeAST, String)> = {
    <head:ParamPair> <rest:("," ParamPair)*> => iter::once(head).chain(rest.into_iter().map(|x|x.1)).collect(),
    => vec![]
};

pub Function: FunctionAST = {
    <ret_type:NumType> <name:Ident> "(" <param_type:ParamList> ")" "{" "}" => FunctionAST {
        name,
        ret_type,
        param_type
    }
};